export default class Node {
    constructor(nodeType, nodeName, nodeValue) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
        this._childNodes = undefined;
    }
    get childNodes() {
        let children = this._childNodes;
        if (children === undefined) {
            children = this._childNodes = new ChildNodes(this);
        }
        return children;
    }
    cloneNode(deep) {
        const node = this._cloneNode();
        if (deep) {
            let child = this.firstChild;
            let nextChild = child;
            while (child !== null) {
                nextChild = child.nextSibling;
                node.appendChild(child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    }
    appendChild(node) {
        if (node.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node.parentNode = this;
        const refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        }
        else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        return node;
    }
    insertBefore(node, refNode) {
        if (refNode == null) {
            return this.appendChild(node);
        }
        if (node.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return;
        }
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
        node.parentNode = this;
        const previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        else {
            node.previousSibling = null;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
    }
    removeChild(refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
    }
    _cloneNode() {
        return new Node(this.nodeType, this.nodeName, this.nodeValue);
    }
}
Node.ELEMENT_NODE = 1 /* ELEMENT_NODE */;
Node.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;
Node.TEXT_NODE = 3 /* TEXT_NODE */;
Node.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;
Node.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */;
Node.ENTITY_NODE = 6 /* ENTITY_NODE */;
Node.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;
Node.COMMENT_NODE = 8 /* COMMENT_NODE */;
Node.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;
Node.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;
Node.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;
Node.NOTATION_NODE = 12 /* NOTATION_NODE */;
function insertFragment(fragment, newParent, before, after) {
    if (!fragment.firstChild) {
        return;
    }
    const firstChild = fragment.firstChild;
    let lastChild = firstChild;
    let node = firstChild;
    firstChild.previousSibling = before;
    if (before) {
        before.nextSibling = firstChild;
    }
    else {
        newParent.firstChild = firstChild;
    }
    while (node) {
        node.parentNode = newParent;
        lastChild = node;
        node = node.nextSibling;
    }
    lastChild.nextSibling = after;
    if (after) {
        after.previousSibling = lastChild;
    }
    else {
        newParent.lastChild = lastChild;
    }
}
class ChildNodes {
    constructor(node) {
        this.node = node;
    }
    item(index) {
        let child = this.node.firstChild;
        for (let i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    }
}
//# sourceMappingURL=node.js.map